{"version":3,"sources":["functionQueuer.jsx"],"names":[],"mappings":"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","file":"functionQueuer.js","sourcesContent":["/**\n* This wraps a function so that anything that calls it waits for reservations\n* to finish before executing.\n*/\n\n// like Promise.all, but doesn't return values or fail\nconst afterPromises = (promises) => {\n    let remainingCount = promises.length;\n    let _resolve;\n    let settle = () => {\n        if (!--remainingCount) {\n            _resolve();\n        }\n    };\n\n    return new Promise(resolve => {\n        _resolve = resolve;\n\n        if (promises.length) {\n            promises.forEach(promise => {\n                promise.then(settle, settle);\n            });\n        } else {\n            resolve();\n        }\n    });\n};\n\nexport default {\n    /**\n    * wraps function so it starts using reservations\n    * @param {Object} options.scope\n    * @param {String} options.name\n    * @example functionQueuer.wrap({ scope: console, name: 'log' })\n    */\n    wrap(options) {\n        const { scope, name } = options;\n\n        const reservations = [];\n\n        /**\n        * adds a reservation for the wrapped function\n        * @return {Promise}\n        */\n        const reserve = () => {\n            let _resolve, _reject;\n\n            let reservation = new Promise((resolve, reject) => {\n                _resolve = resolve;\n                _reject = reject;\n            });\n\n            reservation.use = (...args) => {\n                const index = reservations.indexOf(reservation);\n\n                if (reservation.used) {\n                    throw 'reservation already used';\n                } else {\n                    reservation.used = true;\n                }\n\n                return afterPromises(reservations.slice(0, index))\n                    .then(() => {\n                        return queuedFunction.original.apply(scope, args);\n                    })\n                    .then(\n                        result => _resolve(result),\n                        result => _reject(result)\n                    );\n            };\n\n            // When reservation is done, remove it.\n            const clear = (result) => {\n                removeReservation(reservation);\n\n                // Relay the reservation result in case someone else\n                // in the chain wants it.\n                return result;\n            };\n\n            // remove the reservation once it's done\n            reservation.then(clear, clear);\n\n            // add to our reservation list\n            reservations.push(reservation);\n\n            return reservation;\n        };\n\n        const queuedFunction = (...args) => {\n            // If you call this directly, we're going to create a reservation for you, you heathen.\n            return reserve().use(...args);\n        };\n\n        const removeReservation = (promise) => {\n            let index = reservations.indexOf(promise);\n            if (index > -1) {\n                reservations.splice(index, 1);\n            }\n            return reservations.length;\n        };\n\n        queuedFunction.reserve = reserve;\n        queuedFunction.original = scope[name];\n\n        scope[name] = queuedFunction;\n    },\n\n    /**\n    * restores original function\n    * @param {Object} options.scope\n    * @param {String} options.name\n    * @example functionQueuer.unwrap({ scope: console, name: 'log' })\n    */\n    unwrap(options) {\n        const { scope, name } = options;\n        scope[name] = scope[name].original;\n    },\n}\n"]}